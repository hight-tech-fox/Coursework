/*В системе двусторонних дорог найти путь из города A в город B с минимальной величиной P+S, 
где S – сумма длин дорог, а P – сумма пошлин за проезд по ним.*/

#include "Header.h" 
#include <iostream>
#include <locale.h>
#include <algorithm>
#include <fstream> //библиотека для работы со строками
using namespace std;

int main()
{
	fstream fin;
	fin.open("input.txt"); //открываем файл с исходными данными
	ofstream fout; //полключаем файловый вывод 
	fout.open("out.txt"); //файловый вывод в out.txt
	setlocale(LC_ALL, "ru"); //подключаем библиотеку русского языка
	int n; //создаем переменную для количества городов
	int m = 0; //переменная для вывода суммы длин дорог
	int c = 0; //переменная для вывода суммы пошлн за проезд
	fin >> n; //считываем первую строку файла в переменную n
	if (n > 1) //если количество городов > 1

		//------------------решение первой подзадачи: поиск значения минимальной суммы P+S-------------------
	{
		int A = Infinity, B = Infinity, i, j; //присваиваем начальному и конечному пунктам значения беск., чтобы они не совпадали с существ. индексами городов, создаем итераторы
		string a, b; //создаем переменные строкового типа для хранения названий начального и конечного пункта
		string* city = new string[n]; // Заводим строковый одномерный массив для хранения названий городов
		for (i = 0; i < n; i++)
			fin >> city[i]; //считываем со второй строки файла названия городов 
		fin >> a >> b; //с 3й строки файла считываем названия A и B

		for (i = 0; i < n; i++) //проходим по массиву с названиями городов
		{
			if (a == city[i]) A = i; //присваиваем А порядковый индекс в массиве городов
			else if (b == city[i]) B = i; //присваиваем B порядковый индекс в массиве городов
		}
		if (B == Infinity || A == Infinity)
		{
			fout << "Начальный и конечный пункты совпадают или не существуют";
		}
		else //A и B существуют и не совпадают
		{
			int price;
			string city1, city2;
			int city_id1, city_id2; //переменные для индексов городов A и B
			int way;
			int** pr = new int* [n]; //готовим таблицу смежности для пошлин за проезд (весовая матрица)
			for (i = 0; i < n; i++)
				pr[i] = new int[n];
			pr = Emptiness(pr, n);
			int** wr = new int* [n];//готовим таблицу смежности для длин дорог (весовая матрица)
			for (i = 0; i < n; i++)
				wr[i] = new int[n];
			wr = Emptiness(wr, n);
			while (fin) //считывание и ввод систем дорог 
			{
				fin >> price >> city1 >> city2 >> way;
				for (int e = 0; e < n; e++)
				{
					if (city1 == city[e]) city_id1 = e;
					else if (city2 == city[e]) city_id2 = e;
				}

				//создали весовую матрицу для цен за проезд по дорогам
				if (pr[city_id1][city_id2] == 0 && price >= 0) //между A и B нет прямой дороги и цена за проезд > 0 
				{
					pr[city_id1][city_id2] = price;
					pr[city_id2][city_id1] = price;
				}
				else if (price < pr[city_id1][city_id2] && price >= 0)
				{
					pr[city_id1][city_id2] = price;
					pr[city_id2][city_id1] = price;
				}
				else if (price < 0) {
					fout << "ERROR: цена за проезд не может быть отрицательна, города: " << city1 << " и " << city2 << '\n';
					return 0;

				}


				//создали весовую матрицу для длин путей
				if (wr[city_id1][city_id2] == 0 && way > 0) //между A и B нет прямой дороги и длина пути > 0
				{
					wr[city_id1][city_id2] = way;
					wr[city_id2][city_id1] = way;
				}
				else if (way < wr[city_id1][city_id2] && way > 0)
				{
					wr[city_id1][city_id2] = way;
					wr[city_id2][city_id1] = way;
				}
				else if (way < 0) {
					fout << "ERROR: длина пути не может быть отрицательна, города: " << city1 << " и " << city2 << '\n';
					return 0;
				}
			}
			int ctrl = 1;
			int** ed = new int* [n]; //составляем таблицу суммы P+S, пошлина за проезд + длина дороги
			for (i = 0; i < n; i++)
				ed[i] = new int[n];
			ed = Summa(pr, wr, ed, n);
			ctrl = Isolation(ed, n, A, B);
			if (ctrl != 0) //если города не изолированы
			{
				int* sh = new int[n]; //Заводим массив для хранения кратчайших расстояний от пункта A, подготовка к исп. алг. Дейкстры
				for (i = 0; i < n; i++)
					sh[i] = Infinity;
				sh[A] = 0;

				sh = DeikstraWay(sh, ed, n); //используем алгоритм Дейкстры

				if (sh[B] != Infinity) //если расстояние от A до B не равно oo
				{
					fout << "Наименьшая сумма длин дорог и пошлин за проезд по ним между городами " << city[A] << " и " << city[B] << '\n';
					fout << sh[B] << '\n';

					//----------решение подзадачи 2: поиск самого пути

					int* v = new int[n]; //Заводим массив для хранения посещенных городов
					for (int i = 0; i < n; i++) v[i] = Infinity;
					v = SameWay(ed, sh, n, A, B, v); //поиск самого пути как траектории

					fout << "Путь в порядке посещения:" << '\n';
					//вывод названий городов (массив в обратном порядке)
					for (int i = n - 1; i >= 0; i--) {
						if (v[i] < Infinity) {
							fout << city[v[i]];
							fout << " -> ";
						}
					}
					fout << "FINAL" << '\n';
					//вывод длин дорог
					fout << "Сумма длин дорог:" << '\n';
					for (int i = 1; i < n; i++) {
						if (v[i] < Infinity) {
							m += wr[v[i]][v[i - 1]];
						}
					}
					fout << m << '\n';
					//вывод суммы пошлин за проезд
					fout << "Сумма пошлин за проезд:" << '\n';
					for (int i = 1; i < n; i++) {
						if (v[i] < Infinity) {
							c += pr[v[i]][v[i - 1]];
						}
					}
					fout << c << '\n';
					cout << "Программа сработала, результат выведен в файл.";
				}
				else fout << "Город изолирован от общей системы дорог" << '\n';
			}
			else fout << "Город изолирован от общей системы дорог" << '\n';
		}
	}
	else fout << "ERROR: введено некорректное количество городов";
	return 0;
	4.
}


